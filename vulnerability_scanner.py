import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import os
import re
from threading import Thread

class VulnerabilityScanner:
    def __init__(self, root):
        self.root = root
        self.root.title("AI-Powered Vulnerability Scanner")
        self.root.geometry("800x600")

        # Variables
        self.selected_path = tk.StringVar()
        self.results = []
        self.status_var = tk.StringVar(value="Ready")

        # GUI Elements
        self.create_widgets()

    def create_widgets(self):
        # File Picker
        tk.Label(self.root, text="Select Project Folder or File:").pack(pady=5)
        frame = tk.Frame(self.root)
        frame.pack(pady=5)
        tk.Entry(frame, textvariable=self.selected_path, width=50).pack(side=tk.LEFT)
        tk.Button(frame, text="Browse", command=self.browse_path).pack(side=tk.LEFT, padx=5)

        # Scan Button
        tk.Button(self.root, text="Scan", command=self.start_scan).pack(pady=10)

        # Status Bar
        tk.Label(self.root, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W).pack(fill=tk.X, side=tk.BOTTOM)

        # Results Panel
        results_frame = tk.Frame(self.root)
        results_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        tk.Label(results_frame, text="Detected Vulnerabilities:").pack(anchor=tk.W)

        self.results_tree = ttk.Treeview(results_frame, columns=("File", "Line", "Type", "Severity"), show="headings")
        self.results_tree.heading("File", text="File")
        self.results_tree.heading("Line", text="Line")
        self.results_tree.heading("Type", text="Type")
        self.results_tree.heading("Severity", text="Severity")
        self.results_tree.pack(fill=tk.BOTH, expand=True)
        self.results_tree.bind("<<TreeviewSelect>>", self.on_result_select)

        # Chatbot Panel
        chatbot_frame = tk.Frame(self.root)
        chatbot_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        tk.Label(chatbot_frame, text="Chatbot Explanation:").pack(anchor=tk.W)
        self.chatbot_text = tk.Text(chatbot_frame, height=10, wrap=tk.WORD)
        self.chatbot_text.pack(fill=tk.BOTH, expand=True)

    def browse_path(self):
        path = filedialog.askdirectory() or filedialog.askopenfilename()
        if path:
            self.selected_path.set(path)

    def start_scan(self):
        path = self.selected_path.get()
        if not path:
            messagebox.showerror("Error", "Please select a path to scan.")
            return
        if not os.path.exists(path):
            messagebox.showerror("Error", "Selected path does not exist.")
            return

        self.status_var.set("Scanning in progress...")
        self.results = []
        self.results_tree.delete(*self.results_tree.get_children())
        self.chatbot_text.delete(1.0, tk.END)

        # Run scan in thread to avoid freezing GUI
        thread = Thread(target=self.scan_path, args=(path,))
        thread.start()

    def scan_path(self, path):
        if os.path.isfile(path):
            files = [path]
        else:
            files = []
            for root, dirs, filenames in os.walk(path):
                for filename in filenames:
                    if filename.endswith(('.py', '.js', '.html')):
                        files.append(os.path.join(root, filename))

        for file_path in files:
            self.scan_file(file_path)

        self.root.after(0, self.update_results)

    def scan_file(self, file_path):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                for i, line in enumerate(lines, 1):
                    vulns = self.detect_vulnerabilities(line)
                    for vuln in vulns:
                        self.results.append({
                            'file': os.path.basename(file_path),
                            'line': i,
                            'type': vuln['type'],
                            'severity': vuln['severity']
                        })
        except Exception as e:
            print(f"Error scanning {file_path}: {e}")

    def detect_vulnerabilities(self, line):
        vulns = []
        # SQL Injection: Simple pattern for unsanitized concatenation in SQL
        if re.search(r"SELECT.*WHERE.*\+.*", line, re.IGNORECASE):
            vulns.append({'type': 'SQL Injection', 'severity': 'High'})
        # XSS: Direct user input in HTML
        if re.search(r"<.*>.*\+.*</.*>", line):
            vulns.append({'type': 'Cross-Site Scripting (XSS)', 'severity': 'High'})
        # Insecure API: eval or exec usage
        if re.search(r"\beval\s*\(", line) or re.search(r"\bexec\s*\(", line):
            vulns.append({'type': 'Insecure API Usage', 'severity': 'Medium'})
        return vulns

    def update_results(self):
        for result in self.results:
            self.results_tree.insert("", tk.END, values=(result['file'], result['line'], result['type'], result['severity']))
        self.status_var.set("Scan complete.")

    def on_result_select(self, event):
        selected = self.results_tree.selection()
        if selected:
            item = self.results_tree.item(selected[0])
            vuln_type = item['values'][2]
            explanation = self.get_explanation(vuln_type)
            self.chatbot_text.delete(1.0, tk.END)
            self.chatbot_text.insert(tk.END, explanation)

    def get_explanation(self, vuln_type):
        explanations = {
            'SQL Injection': """
Why dangerous: SQL Injection allows attackers to execute arbitrary SQL code by injecting malicious input into queries, potentially leading to data theft, modification, or deletion.

Suggested fix: Use parameterized queries or prepared statements. For example, in Python with sqlite3:
cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
Instead of concatenating strings.
""",
            'Cross-Site Scripting (XSS)': """
Why dangerous: XSS enables attackers to inject malicious scripts into web pages viewed by other users, leading to session hijacking, defacement, or malware distribution.

Suggested fix: Sanitize user input and escape output. Use libraries like html.escape() in Python or equivalent in other languages. Avoid directly inserting user data into HTML.
""",
            'Insecure API Usage': """
Why dangerous: Using eval() or exec() with untrusted input can execute arbitrary code, leading to full system compromise.

Suggested fix: Avoid eval() and exec() altogether. Use safe alternatives like ast.literal_eval() for parsing literals, or refactor to use secure APIs.
"""
        }
        return explanations.get(vuln_type, "No explanation available.")

if __name__ == "__main__":
    root = tk.Tk()
    app = VulnerabilityScanner(root)
    root.mainloop()
